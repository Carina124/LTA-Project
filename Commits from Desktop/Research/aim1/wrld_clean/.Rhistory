#n = pop.size,
#which.loc = c("CSF1PO",
#"D3S1358",
#"D5S818",
#"D7S820",
#"D8S1179",
#"D13S317",
#"D16S539",
#"D18S51",
#"D21S11",
#"FGA",
#"TH01",
#"TPOX",
#"VWA"
#)
#)
#SIMUMIX objects store DNA mixtures#########
####noncontrib is the simulated genotype data
#### ncontri is the number of contributors to the mixture
#this use to use noncontrib but I didn't see how it was diff from sim. genotypes
noncon.sus <- simumix(sim.genotypes,
ncontri = num_contribs
)
###### QUESTION: Why do we need this here if we make the mixutres inside the loop? probably two diff populations
#commenting out for now
## Inititialize variables for vector ##
csf.2 <- pop.afs$tab$population$CSF1PO
d3s.2 <- pop.afs$tab$population$D3S1358
#D2S1338 *changed out for a diff STR
d2s.2 <- pop.afs$tab$population$D5S818
d7s.2 <- pop.afs$tab$population$D7S820
d8s.2 <- pop.afs$tab$population$D8S1179
d16.2 <- pop.afs$tab$population$D16S539
d18.2 <- pop.afs$tab$population$D18S51
d21.2 <- pop.afs$tab$population$D21S11
fga.2 <- pop.afs$tab$population$FGA
th01.2 <- pop.afs$tab$population$TH01
tp0x.2 <- pop.afs$tab$population$TPOX
vwa.2 <- pop.afs$tab$population$VWA
#D19S433 *
d19.2 <- pop.afs$tab$population$D13S317
## Creating Matrix ## Numeric, 45? Not sure this is working
pop.afs.matrix <- matrix(list(),
nrow = 13,
ncol = 1
)
pop.afs.matrix[[1,1]] <- c(d8s.2)
pop.afs.matrix[[2,1]] <- c(th01.2)
pop.afs.matrix[[3,1]] <- c(fga.2)
pop.afs.matrix[[4,1]] <- c(csf.2)
pop.afs.matrix[[5,1]] <- c(tp0x.2)
pop.afs.matrix[[6,1]] <- c(d3s.2)
pop.afs.matrix[[7,1]] <- c(d7s.2)
pop.afs.matrix[[8,1]] <- c(d16.2)
pop.afs.matrix[[9,1]] <- c(d18.2)
pop.afs.matrix[[10,1]] <- c(d21.2)
pop.afs.matrix[[11,1]] <- c(d2s.2)
pop.afs.matrix[[12,1]] <- c(d19.2)
pop.afs.matrix[[13,1]] <- c(vwa.2)
#total_LR <- c()
#LR_vector <- c()
log10_LR <- c(1:num_sims)
#  If non.or.truecontrib == 0 then we are simulationing a mixture where the
# suspect did not contribute DNA to the sample
##############################
### true contributor code ####
##############################
#is a true contributor mix   #loop 1:
if (non.or.truecontrib == 0){
j = 1
#I think this should be <=
while (j < num_sims){
#simulate a mixture using the simulated genotypes that consider this populations
#allele frequencies for the appropriate population size
sim.mix <- simumix(sim.genotypes,
ncontri = num_contribs
)
singleLR_vector <- c()
#loop 2:
if (num_contribs == 1){
k = 1
#K stops at 14 because we are considering the 13 core STR loci
while (k < 14){
single_LR <- LR( Repliste = c(sim.mix$mix.all[[k]]),
Tp = c(as.numeric(strsplit(sim.mix$mix.prof[1,k], "/")[[1]])),
Td = 0,
Vp = 0,
Vd = c(as.numeric(strsplit(sim.mix$mix.prof[1,k], "/")[[1]])),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#print(single_LR$LR)
singleLR_vector <- c(singleLR_vector,single_LR$LR)
k = k + 1
}
}
#if more than one contributor it goes here
else {
#loop 3## LR Calculation
k = 1
while (k < 14){
prosecutor.all.atk = c()
for(i in 1:num_contribs){
### QUESTION: why do we need to use strsplit ? Rename these alleles so they make sense
prosecutor.all.atk = c(prosecutor.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i,k], "/")[[1]])
)
}
defense.all.atk = c()
#i think num_contribs should be the same as above (i in 1:(num_contribs - 1)
for (i in 1:(num_contribs - 1)){
defense.all.atk = c(defense.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i, k], "/")[[1]])
)
}
#Loop 4 # detail what goes in each var
single_LR <<- LR( Repliste = c(sim.mix@mix.all[[k]]),
Tp = c(prosecutor.all.atk),
## Vd = Non contrib under Hd - Suspect ##
Td = c(defense.all.atk),
#tells Dorothy to return the last two digits of vector (dont think we need the strsplit commands)
Vp = 0,
## Vp = Non contrib under Hp - 0 ##
Vd = c(as.numeric(tail(prosecutor.all.atk,2), "/")[[1]]),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#######################################
##### Not using this while loop #######
######################################
#while(is.na(single_LR$LR) || is.infinite(single_LR$LR) || is.nan(single_LR$LR) || single_LR$LR<0){
#single_LR <- LR( Repliste = c(sim.mix@mix.all[[k]]),
#Tp = c(prosecutor.all.atk),
#Td = c(defense.all.atk),
##Vd = Non contrib under Hd - Suspect ##
# Vp = 0,
## Vp = Non contrib under Hp - 0 ##
#Vd = c(as.numeric(tail( prosecutor.all.atk,2), "/")[[1]]),
#xd = 1,
# xp = 0,
# theta = 0,
#prDHet = c(0.2,0.2),
#prDHom = c(0.04,0.04),
#prC = 0,
#freq = pop.afs.matrix[[k,1]]
# )
#print(paste("in stupid while loop", k))
#end of while(is.na(single_LR$LR) || is.infinite(single_LR$LR) || is.nan(single_LR$LR) || single_LR$LR<0)
# }
print(single_LR$LR)
if ((single_LR$LR) == "Inf"){
single_LR$LR <- 1
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
} else {
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
}
print(singleLR_vector)
#singleLR_vector <<- c(singleLR_vector,single_LR$LR)
k = k + 1
#end of while (k < 14), for LR calculation
}
#end of else, for more than 1 contributor
}
print(prod(singleLR_vector))
print(log10(prod(singleLR_vector)))
### Q:annot find log10 is not found ????
print(log10_LR[j] <<- log10(prod(singleLR_vector)))
j = j + 1
#end of while (j < num_sims)
}
#end of if (non.or.truecontrib == 0)
}
##########################
### non contributors #####
##########################
else if (non.or.truecontrib == 1){
j = 1
#set.seed(657)
#loop over num_sims
while (j < num_sims){
sim.mix <- simumix(sim.genotypes,
ncontri = num_contribs
)
#Q344#I think we should make this person here, but need clarity on what it should be
#noncon.sus <- simumix(noncontrib,
#ncontri = (num_contribs)
# )
singleLR_vector <- c()
#log10_LRvector <- c()
if (num_contribs == 1){
k = 1
while (k < 14){
single_LR <- LR(Repliste = c(sim.mix$mix.all[[k]]),
Tp = c(as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
Td = 0,
Vp = 0,
Vd = c(as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#print(list_Alleles)
singleLR_vector <- c(singleLR_vector,single_LR$LR)
k = k + 1
}
}
else {
k = 1
while (k < 14){
#9/12 c = num_contribs - 1
prosecutor.all.atk = c()
################################################################
## I changed the { } for these loops so that for(i in 1:c) is ##
## not included in loop for(i in 1:num_contribs). this was a  ##
## issue rori mentioned at meeting 8/30 - CK :)               ##
################################################################
for(i in 1:num_contribs){
prosecutor.all.atk = c(prosecutor.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i,k],
"/")[[1]])
)
}
defense.all.atk = c()
for (i in 1:(num_contribs - 1)){
defense.all.atk = c(defense.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i,k],
"/")[[1]])
)
}
single_LR <- LR( Repliste = c(sim.mix$mix.all[[k]]),
Tp = c(prosecutor.all.atk,
as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
Td = c(defense.all.atk),
Vp = 0,
Vd = c(as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#while(is.na(single_LR$LR) || is.infinite(single_LR$LR) || is.nan(single_LR$LR) || single_LR$LR<0){
#single_LR <- LR( Repliste = c(sim.mix$mix.all[[k]]),
#Tp = c(prosecutor.all.atk,
#as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
#Td = c(defense.all.atk),
# Vp = 0,
#Vd = c(as.numeric(strsplit(noncon.sus$mix.prof[1,k], "/")[[1]])),
#xd = 1,
#xp = 0,
#theta = 0,
# prDHet = c(0.2,0.2),
#prDHom = c(0.04,0.04),
#prC = 0,
# freq = pop.afs.matrix[[k,1]]
#)
# }
print(single_LR$LR)
####### replces inf with 1 ######
if ((single_LR$LR) == "Inf"){
single_LR$LR <- 1
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
} else {
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
}
# singleLR_vector <- c(singleLR_vector,single_LR$LR)
k = k + 1
#end of  while (k < 14)
}
#end of else, for more than 1 contributor
}
log10_LR[j] <- log10(prod(singleLR_vector))
j = j + 1
#end of while (j < num_sims), which loops over num_sims
}
#end of else if (non.or.truecontrib == 1)
}
#singleLRs_vec_product[j] - this is what I want reterned
return(log10_LR)
#end of total_contrib_function <- function(file.name,pop.size,num_contribs,num_sims,non.or.truecontrib)
}
lrs <- total_contrib_function("USAf.1_new.csv", 15, 4, 5, 1)
lrs
lrs <- total_contrib_function("USAf.1_new.csv", 15, 4, 10, 1)
lrs
lrs <- total_contrib_function("USAf.1_new.csv", 15, 4, 101, 1)
lrs
lrs <- total_contrib_function("USAf.1_new.csv", 15, 4, 11, 0)
#setting up the empty 3d array, rows are pop, columns are # of contrib, iteate-1 is the sheets of the cube
array_3d = array(rep(1,1000*8*11), dim =c(1000,8,11))
#view empty array
array_3d
file_names
exp_hmat
mean_vec
#Vectors for world data
file_names
#intiates the vector that holds all exp heterozygosity values
exp_hvec <- c()
exp_hmat <- matrix(data = NA, nrow = length(file_names), ncol = length(loci_vec))
#loop that iterates through the 13 loci in Loci_vec
for (locus_i in 1:length(loci_vec)){
current_locus <- loci_vec[locus_i]
#loop iterates through each CSV file
for( pop_i in 1:length(file_names)){
#fixed the col spec outputs
afs_matrix <- as.matrix(read.csv(file_names[pop_i]))
#loop iterates through colums of file and checks if it matches current loci
for (i in 3:dim(afs_matrix)[2]){
name =  colnames(afs_matrix)[i]
if(name == current_locus){
cur_afs <- afs_matrix[,i]
if (sum(as.numeric(cur_afs)) >= 1.01 || sum(as.numeric(cur_afs))<=.99){
print(paste("Sum is out of bounds",loci_vec[locus_i],file_names[pop_i],sum(as.numeric(cur_afs))))
}
afs_sqrd <- as.numeric(cur_afs)^2
#loci_sum <- sum(afs_sqrd)
exp_hetero <- (1 -(sum(afs_sqrd)))
#where you are putting it/what you are putting in it
exp_hmat[pop_i,locus_i] <- exp_hetero
#print(paste("heterozygosity for locus  ",current_locus,"for pop ",j, "is ",exp_hetero))
}
}
}
}
#assigns the col name to the matrix from the freq vector (changes)
colnames(exp_hmat) <- loci_vec
#asigns the row name to the matrix (changes)
rownames(exp_hmat) <- file_names
write.csv(exp_hmat,"Exp_hetero_wrld.csv")
mean_vec <- c()
for( i in 1:length(exp_hmat)){
mean_exp <- mean(exp_hmat[i,])
mean_vec <-c(mean_vec,mean_exp)
}
# turns the vector into a matrix
exphetero_mat <- as.matrix(mean_vec, ncol=2)
colnames(exphetero_mat) <- "Average Expected Heterozygosity"
colnames(exp)
#asigns the row name to the matrix (changes)
rownames(exphetero_mat) <- file_names
write.csv(exphetero_mat,"Average_Expected_Heterowrold.csv")
###### Removing populations without the STR core ############
colSums(is.na(exphetero_mat))
sum(is.na(exphetero_mat))
exphetero_mat_clean <- na.omit(exphetero_mat)
exphetero_mat_clean
mean_vec
#total_LR <- c()
#LR_vector <- c()
log10_LR <- c(1:num_sims)
log10_LR
j = 1
#I think this should be <=
while (j < num_sims){
#simulate a mixture using the simulated genotypes that consider this populations
#allele frequencies for the appropriate population size
sim.mix <- simumix(sim.genotypes,
ncontri = num_contribs
)
singleLR_vector <- c()
#loop 2:
if (num_contribs == 1){
k = 1
#K stops at 14 because we are considering the 13 core STR loci
while (k < 14){
single_LR <- LR( Repliste = c(sim.mix$mix.all[[k]]),
Tp = c(as.numeric(strsplit(sim.mix$mix.prof[1,k], "/")[[1]])),
Td = 0,
Vp = 0,
Vd = c(as.numeric(strsplit(sim.mix$mix.prof[1,k], "/")[[1]])),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#print(single_LR$LR)
singleLR_vector <- c(singleLR_vector,single_LR$LR)
k = k + 1
}
}
#if more than one contributor it goes here
else {
#loop 3## LR Calculation
k = 1
while (k < 14){
prosecutor.all.atk = c()
for(i in 1:num_contribs){
### QUESTION: why do we need to use strsplit ? Rename these alleles so they make sense
prosecutor.all.atk = c(prosecutor.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i,k], "/")[[1]])
)
}
defense.all.atk = c()
#i think num_contribs should be the same as above (i in 1:(num_contribs - 1)
for (i in 1:(num_contribs - 1)){
defense.all.atk = c(defense.all.atk,
as.numeric(strsplit(sim.mix$mix.prof[i, k], "/")[[1]])
)
}
#Loop 4 # detail what goes in each var
single_LR <<- LR( Repliste = c(sim.mix@mix.all[[k]]),
Tp = c(prosecutor.all.atk),
## Vd = Non contrib under Hd - Suspect ##
Td = c(defense.all.atk),
#tells Dorothy to return the last two digits of vector (dont think we need the strsplit commands)
Vp = 0,
## Vp = Non contrib under Hp - 0 ##
Vd = c(as.numeric(tail(prosecutor.all.atk,2), "/")[[1]]),
xd = 1,
xp = 0,
theta = 0,
prDHet = c(0.2,0.2),
prDHom = c(0.04,0.04),
prC = 0,
freq = pop.afs.matrix[[k,1]]
)
#######################################
##### Not using this while loop #######
######################################
#while(is.na(single_LR$LR) || is.infinite(single_LR$LR) || is.nan(single_LR$LR) || single_LR$LR<0){
#single_LR <- LR( Repliste = c(sim.mix@mix.all[[k]]),
#Tp = c(prosecutor.all.atk),
#Td = c(defense.all.atk),
##Vd = Non contrib under Hd - Suspect ##
# Vp = 0,
## Vp = Non contrib under Hp - 0 ##
#Vd = c(as.numeric(tail( prosecutor.all.atk,2), "/")[[1]]),
#xd = 1,
# xp = 0,
# theta = 0,
#prDHet = c(0.2,0.2),
#prDHom = c(0.04,0.04),
#prC = 0,
#freq = pop.afs.matrix[[k,1]]
# )
#print(paste("in stupid while loop", k))
#end of while(is.na(single_LR$LR) || is.infinite(single_LR$LR) || is.nan(single_LR$LR) || single_LR$LR<0)
# }
print(single_LR$LR)
if ((single_LR$LR) == "Inf"){
single_LR$LR <- 1
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
} else {
singleLR_vector <<- c(singleLR_vector,single_LR$LR)
}
print(singleLR_vector)
#singleLR_vector <<- c(singleLR_vector,single_LR$LR)
k = k + 1
#end of while (k < 14), for LR calculation
}
#end of else, for more than 1 contributor
}
print(prod(singleLR_vector))
print(log10(prod(singleLR_vector)))
### Q:annot find log10 is not found ????
print(log10_LR[j] <<- log10(prod(singleLR_vector)))
j = j + 1
#end of while (j < num_sims)
}
log10_LR
tabfreq
pop.afs$tab
x = MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL
x = c(MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL)
length(MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL)
x = c("MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL")
length(x)
unlist(x)
length(unlist(x))
nchar(x)
nchar
nchar(MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL)
x = c(MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL)
nchar
x = c("MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL")
nchar(x)
A = c("MAVQQNKPIFTKIEMRRSFDALTAETSLSNDITSGEKHLRLHITGDGYYRGRKVIGL")
B = c("MAVQQNKPTRSKRHMRRSHDALLAVTSLSVEKTSGEKHLRHHITADGDYRGRKVLAK")
C = c("MADQQNKPTRSKRHMRRSHDALTAVLSLSVEKTSGEKHLRLHITADGYYRERKVLAK")
D = c("MVTQTNKPTRTKNGIRRSHLALTAETFLSVDKTSGEKHLRHHMEADGYYRGRKGIAL")
nchar(A,B,C,D)
nchar(A)
if (nchar(A) == nchar(b)){
print("true")
}
if (nchar(A) == nchar(B)){
print("true")
}
count = 0
if (1:nchar(A) == 1:nchar(B)){
print("true")
}
